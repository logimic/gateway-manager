/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface CfgDaemonComponentRequest100 {
  /**
   * General component configuration.
   */
  mType: "cfgDaemon_Component";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Component name.
       */
      componentName: string;
      /**
       * Component instance.
       */
      componentInstance: string;
      /**
       * Configuration Json.
       */
      configuration: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface CfgDaemonComponentResponse100 {
  /**
   * General component configuration.
   */
  mType: "cfgDaemon_Component";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Component name.
       */
      componentName: string;
      /**
       * Component instance.
       */
      componentInstance: string;
      [k: string]: any;
    };
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshBondNodeLocalRequest100 {
  /**
   * iqmesh_ Network management - Bond Node Local request.
   */
  mType: "iqmesh_BondNodeLocal";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Number of repetitions of DPA messages.
     */
    repeat?: number;
    req: {
      /**
       * Address to bond the device to.
       */
      deviceAddr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshBondNodeLocalResponse100 {
  /**
   * iqmesh_ Network management - Bond Node Local response.
   */
  mType: "iqmesh_BondNodeLocal";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Returns following values, see its description.
     */
    rsp: {
      /**
       * Assigned address to the node.
       */
      assignedAddr: number;
      /**
       * Number of nodes in the network.
       */
      nodesNr: number;
      /**
       * Profile integer.
       */
      hwpId: number;
      /**
       * Manufacture name.
       */
      manufacturer: string;
      /**
       * Product name.
       */
      product: string;
      /**
       * Returns following values, see its description.
       */
      osReadRsp?: {
        /**
         * TR Module ID.
         */
        mid: string;
        /**
         * IQRF OS version.
         */
        osVersion?: string;
        /**
         * TR MCU type.
         */
        trMcuType?: string;
        /**
         * IQRF OS build.
         */
        osBuild?: string;
        /**
         * See lastRSSI at IQRF OS Reference Guide.
         */
        rssi?: number;
        /**
         * Module supply voltage
         */
        supplyVoltage?: string;
        /**
         * See DPA guide.
         */
        flags?: number;
        /**
         * See DPA guide.
         */
        slotLimits?: number;
        [k: string]: any;
      };
      [k: string]: any;
    };
    /**
     * Returns array of objects req-cnf-rsp, see its description.
     */
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    }[];
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshEnumerateDeviceRequest100 {
  /**
   * iqmesh_ Network management - Enumerate Device request.
   */
  mType: "iqmesh_EnumerateDevice";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Number of repetitions of DPA messages.
     */
    repeat?: number;
    req: {
      /**
       * Device address to enumerate.
       */
      deviceAddr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type UnionResponses =
  | IqmeshEnumDevice1
  | IqmeshEnumDevice2
  | IqmeshEnumDevice3
  | IqmeshEnumDevice4
  | IqmeshEnumDevice5
  | IqmeshEnumDevice6;
/**
 * Returns the same information as Get peripheral information but for up to 14 peripherals of consecutive indexes starting with the specified PCMD.
 */
export type IqmeshEnumDevice5 = {
  /**
   * Extended peripheral characteristic. See Extended Peripheral Characteristic constants.
   */
  perTe: number;
  /**
   * Peripheral type. If the peripheral is not supported or enabled, then PerTx = PERIPHERAL_TYPE_DUMMY. See Peripheral Types constants.
   */
  perT: number;
  /**
   * Optional peripheral specific information.
   */
  par1?: number;
  /**
   * Optional peripheral specific information.
   */
  par2?: number;
  [k: string]: any;
}[];

export interface IqmeshEnumerateDeviceResponse100 {
  /**
   * iqmesh_ Network management - Enumerate Device response.
   */
  mType: "iqmesh_EnumerateDevice";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Returns following values, see its description.
     */
    rsp: {
      /**
       * Device address to enumerate.
       */
      deviceAddr: number;
      result: UnionResponses;
      [k: string]: any;
    };
    /**
     * Returns array of objects req-cnf-rsp, see its description.
     */
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    }[];
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * First response.
 */
export interface IqmeshEnumDevice1 {
  /**
   * Device is discovered.
   */
  discovered: boolean;
  /**
   * Device VRN integer.
   */
  vrn: number;
  /**
   * Device zone.
   */
  zone: number;
  /**
   * Device parent.
   */
  parent: number;
  [k: string]: any;
}
/**
 * Second response - reduced or full eperOsRead.
 */
export interface IqmeshEnumDevice2 {
  /**
   * TR Module ID.
   */
  mid: string;
  /**
   * IQRF OS version.
   */
  osVersion: string;
  /**
   * TR MCU type.
   */
  trMcuType?: string;
  /**
   * IQRF OS build.
   */
  osBuild: string;
  /**
   * See lastRSSI at IQRF OS Reference Guide.
   */
  rssi?: number;
  /**
   * Module supply voltage
   */
  supplyVoltage?: string;
  /**
   * See DPA guide.
   */
  flags?: number;
  /**
   * See DPA guide.
   */
  slotLimits?: number;
  [k: string]: any;
}
/**
 * Third response - reduced or full eperExploreEnum.
 */
export interface IqmeshEnumDevice3 {
  /**
   * DPA version.
   */
  dpaVer: string;
  /**
   * Number of all non-embedded peripherals implemented by Custom DPA Handler.
   */
  perNr?: number;
  /**
   * Bits array (starting from LSb of the 1st byte) specifying which of 32 embedded peripherals are enabled in the HWP Configuration.
   */
  embPers?: number[];
  /**
   * Hardware profile identification.
   */
  hwpId: string;
  /**
   * Hardware profile version.
   */
  hwpIdVer: number;
  /**
   * Various flags.
   */
  flags?: number;
  /**
   * Bits array (starting from LSb of the 1st byte) specifying which of non-embedded peripherals are implemented.
   */
  userPers?: number[];
  [k: string]: any;
}
/**
 * Fourth response - reduced or full eperOsReadCfg.
 */
export interface IqmeshEnumDevice4 {
  /**
   * Checksum of the Configuration part.
   */
  checkSum?: number;
  /**
   * Content the configuration memory block from address 0x01 to 0x1F.
   */
  cfgBytes: number[];
  /**
   * See parameter of setupRFPGM IQRF OS function.
   */
  rfPgm: number;
  undocumented?: number;
  [k: string]: any;
}
/**
 * Sixth response - validation and updates.
 */
export interface IqmeshEnumDevice6 {
  /**
   * IQRF OS version + build, DPA version, TX power, RX filter same as Coordinator.
   */
  validation: {
    /**
     * All is fine.
     */
    valid: boolean;
    /**
     * IQRF OS version.
     */
    osVer?: string;
    /**
     * IQRF OS build.
     */
    osBuild?: string;
    /**
     * IQRF DPA version.
     */
    dpaVer?: string;
    /**
     * TX power.
     */
    txPower?: number;
    /**
     * RX filter.
     */
    rxFilter?: number;
    [k: string]: any;
  };
  /**
   * Available updates from IQRF repository.
   */
  updates?: {
    /**
     * Path to the up to date DPA handler.
     */
    dpaHandlerPath?: string;
    /**
     * Path to the up to date DPA plugin.
     */
    dpaPluginPath?: string;
    /**
     * Path to the up to date OS+DPA plugin.
     */
    osDpaPluginPath?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshOtaUploadRequest100 {
  /**
   * iqmesh_ Network management - Upload hex or iqrf file request.
   */
  mType: "iqmesh_OtaUpload";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Number of repetitions of DPA messages.
     */
    repeat?: number;
    req: {
      /**
       * Device address(es) to write the hex or iqrf file.
       */
      deviceAddr: number[];
      /**
       * Full name of file with source code to load.
       */
      fileName: string;
      /**
       * Start address on which will be the data saved into memory.
       */
      startMemAddr: number;
      /**
       * Loading action - WithoutCodeLoading, WithCodeLoading.
       */
      loadingAction: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshOtaUploadResponse100 {
  /**
   * iqmesh_ Network management - Upload hex or iqrf file response.
   */
  mType: "iqmesh_OtaUpload";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Returns following values, see its description.
     */
    rsp: {
      /**
       * Device address to write the configuration to. Broadcast address is also allowed.
       */
      deviceAddr: number;
      /**
       * If sets, then selected file has been successfully loaded.
       */
      writeSuccess: boolean;
      [k: string]: any;
    };
    /**
     * Returns array of objects req-cnf-rsp, see its description.
     */
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    }[];
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshReadTrConfRequest100 {
  /**
   * iqmesh_ Network management - Read TR configuration request.
   */
  mType: "iqmesh_ReadTrConf";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Number of repetitions of DPA messages.
     */
    repeat?: number;
    req: {
      /**
       * Device address(es) to read the configuration from.
       */
      deviceAddr: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshReadTrConfResponse100 {
  /**
   * iqmesh_ Network management - Read TR configuration response.
   */
  mType: "iqmesh_ReadTrConf";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Returns following values, see its description.
     */
    rsp: {
      /**
       * Device address to read the configuration from.
       */
      deviceAddr: number;
      /**
       * An array of 32 bits. Each bit enables/disables one of the embedded 32 predefined peripherals.
       */
      embPerBits: number[];
      /**
       * Used RF band.
       */
      rfBand: string;
      /**
       * Main RF channel A of the main network. Valid numbers depend on used RF band.
       */
      rfChannelA: number;
      /**
       * Same as above but second B channel. Used at RFPGM only.
       */
      rfChannelB: number;
      /**
       * Main RF channel A of the optional subordinate network in case the node also plays a role of the coordinator of such network. Valid numbers depend on used RF band.
       */
      rfSubChannelA: number;
      /**
       * Same as above but second B channel.
       */
      rfSubChannelB: number;
      /**
       * RF output power. Valid numbers 0-7.
       */
      txPower: number;
      /**
       * RF signal filter. Valid numbers 0-64.
       */
      rxFilter: number;
      /**
       * Timeout for receiving RF packets at LP mode at N device.
       */
      lpRxTimeout: number;
      /**
       * A nonzero value specifies an alternative DPA service mode channel.
       */
      rfPgmAltChannel: number;
      /**
       * If sets, then activates RFPGM invoking by TR module reset.
       */
      rfPgmEnableAfterReset: boolean;
      /**
       * If sets, then terminates RFPGM automatically ~1 minute after reset.
       */
      rfPgmTerminateAfter1Min: boolean;
      /**
       * If sets, then terminates RFPGM by dedicated pin of the TR module.
       */
      rfPgmTerminateMcuPin: boolean;
      /**
       * If sets, then enables single or dual channel function.
       */
      rfPgmDualChannel: boolean;
      /**
       * RFPGM receiving mode setting. If set, then LP (low power) Rx mode is used during RFPGM. Otherwise STD (standard) Rx mode is used.
       */
      rfPgmLpMode: boolean;
      /**
       * Read only. Indicates that the last RFPGM has successfully been completed.
       */
      rfPgmIncorrectUpload: boolean;
      /**
       * If set, then a Custom DPA handler is called in case of an event.
       */
      customDpaHandler: boolean;
      /**
       * If set, then Node device can be controlled by a SPI or UART interface.
       */
      nodeDpaInterface: boolean;
      /**
       * Baud rate of the UART interface if one is used.
       */
      uartBaudrate: number;
      /**
       * If set, then DPA Autoexec is run at a later stage of the module boot time.
       */
      dpaAutoexec: boolean;
      /**
       * If set, then the Node device does not route packets on the background.
       */
      routingOff: boolean;
      /**
       * If set, then DPA IO Setup is run at an early stage of the module boot time.
       */
      ioSetup: boolean;
      /**
       * If set, then device receives also peer-to-peer (non-networking) packets and raises PeerToPeer event.
       */
      peerToPeer: boolean;
      [k: string]: any;
    };
    /**
     * Returns array of objects req-cnf-rsp, see its description.
     */
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    }[];
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshWriteTrConfRequest100 {
  /**
   * iqmesh_ Network management - Write TR configuration request.
   */
  mType: "iqmesh_WriteTrConf";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Number of repetitions of DPA messages.
     */
    repeat?: number;
    /**
     * Restart required after writing the configuration.
     */
    restart?: boolean;
    req: {
      /**
       * Device address(es) to write the configuration to. Broadcast address is also allowed.
       */
      deviceAddr: number[];
      /**
       * Used RF band.
       */
      rfBand?: string;
      /**
       * Main RF channel A of the main network. Valid numbers depend on used RF band.
       */
      rfChannelA?: number;
      /**
       * Same as above but second B channel. Used at RFPGM only.
       */
      rfChannelB?: number;
      /**
       * Main RF channel A of the optional subordinate network in case the node also plays a role of the coordinator of such network. Valid numbers depend on used RF band.
       */
      rfSubChannelA?: number;
      /**
       * Same as above but second B channel.
       */
      rfSubChannelB?: number;
      /**
       * RF output power. Valid numbers 0-7.
       */
      txPower?: number;
      /**
       * RF signal filter. Valid numbers 0-64.
       */
      rxFilter?: number;
      /**
       * Timeout for receiving RF packets at LP mode at N device.
       */
      lpRxTimeout?: number;
      /**
       * A nonzero value specifies an alternative DPA service mode channel.
       */
      rfPgmAltChannel?: number;
      /**
       * If sets, then activates RFPGM invoking by TR module reset.
       */
      rfPgmEnableAfterReset?: boolean;
      /**
       * If sets, then terminates RFPGM automatically ~1 minute after reset.
       */
      rfPgmTerminateAfter1Min?: boolean;
      /**
       * If sets, then terminates RFPGM by dedicated pin of the TR module.
       */
      rfPgmTerminateMcuPin?: boolean;
      /**
       * If sets, then enables single or dual channel function.
       */
      rfPgmDualChannel?: boolean;
      /**
       * RFPGM receiving mode setting. If set, then LP (low power) Rx mode is used during RFPGM. Otherwise STD (standard) Rx mode is used.
       */
      rfPgmLpMode?: boolean;
      /**
       * Read only. Indicates that the last RFPGM has successfully been completed.
       */
      rfPgmIncorrectUpload?: boolean;
      /**
       * If set, then a Custom DPA handler is called in case of an event.
       */
      customDpaHandler?: boolean;
      /**
       * If set, then Node device can be controlled by a SPI or UART interface.
       */
      nodeDpaInterface?: boolean;
      /**
       * Baud rate of the UART interface if one is used.
       */
      uartBaudrate?: number;
      /**
       * If set, then DPA Autoexec is run at a later stage of the module boot time.
       */
      dpaAutoexec?: boolean;
      /**
       * If set, then the Node device does not route packets on the background.
       */
      routingOff?: boolean;
      /**
       * If set, then DPA IO Setup is run at an early stage of the module boot time.
       */
      ioSetup?: boolean;
      /**
       * If set, then device receives also peer-to-peer (non-networking) packets and raises PeerToPeer event.
       */
      peerToPeer?: boolean;
      /**
       * It sets security password. If the field is left completely empty (no characters filled), the default password (16x number 0x00) is used (the same as the default set from the factory.
       */
      securityPassword?: string;
      /**
       * It sets security user key. Enter a value up to 16 characters.
       */
      securityUserKey?: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqmeshWriteTrConfResponse100 {
  /**
   * iqmesh_ Network management - Write TR configuration response.
   */
  mType: "iqmesh_WriteTrConf";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Returns following values, see its description.
     */
    rsp: {
      /**
       * Device address to write the configuration to. Broadcast address is also allowed.
       */
      deviceAddr: number;
      /**
       * If sets, then configuration has been successfully written.
       */
      writeSuccess: boolean;
      /**
       * Restart required, but not done yet.
       */
      restartNeeded: boolean;
      [k: string]: any;
    };
    /**
     * Returns array of objects req-cnf-rsp, see its description.
     */
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    }[];
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfBinaryoutputEnumerateRequest100 {
  /**
   * Standard peripheral Binary Output - Enumeration request.
   */
  mType: "iqrfBinaryoutput_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfBinaryoutputEnumerateResponse100 {
  /**
   * Standard peripheral Binary Output - Enumeration response.
   */
  mType: "iqrfBinaryoutput_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of implemented binary outputs.
       */
      binOuts: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfBinaryoutputSetOutputRequest100 {
  /**
   * Standard peripheral Binary Output - Set Output request.
   */
  mType: "iqrfBinaryoutput_SetOutput";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of objects with the following fields.
       */
      binOuts: {
        /**
         * Zero based index of the light to set.
         */
        index: number;
        /**
         * true to set ON state, false to set OFF state.
         */
        state: boolean;
        /**
         * Time in seconds. Allowed values are <1;127> or 60*<1;127>.
         */
        time?: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfBinaryoutputSetOutputResponse100 {
  /**
   * Standard peripheral Binary Output - Set Output request.
   */
  mType: "iqrfBinaryoutput_SetOutput";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array of boolean true/false values specifying the previous state of each binary output. false is returned for unimplemented binary outputs.
       */
      prevVals: boolean[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorAddrInfoRequest100 {
  /**
   * Embedded peripheral Coordinator - Addressing Information request.
   */
  mType: "iqrfEmbedCoordinator_AddrInfo";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorAddrInfoResponse100 {
  /**
   * Embedded peripheral Coordinator - Addressing Information response.
   */
  mType: "iqrfEmbedCoordinator_AddrInfo";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of bonded network nodes.
       */
      devNr: number;
      /**
       * Discovery ID of the network.
       */
      did: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorAuthorizeBondRequest100 {
  /**
   * Embedded peripheral Coordinator - Authorize Bond request.
   */
  mType: "iqrfEmbedCoordinator_AuthorizeBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * See Bond node request. If 0xFF is specified then the pre-bonded node is unbonded and then reset.
       */
      reqAddr: number;
      /**
       * Module ID of the node to be authorized.
       */
      mid: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorAuthorizeBondResponse100 {
  /**
   * Embedded peripheral Coordinator - Authorize Bond response.
   */
  mType: "iqrfEmbedCoordinator_AuthorizeBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Address of the node newly bonded to the network.
       */
      bondAddr: number;
      /**
       * Number of bonded network nodes.
       */
      devNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBackupRequest100 {
  /**
   * Embedded peripheral Coordinator - Backup request.
   */
  mType: "iqrfEmbedCoordinator_Backup";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Index of the block of data.
       */
      index: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBackupResponse100 {
  /**
   * Embedded peripheral Coordinator - Backup response.
   */
  mType: "iqrfEmbedCoordinator_Backup";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * One block of the coordinator network info data.
       */
      netData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBondedDevicesRequest100 {
  /**
   * Embedded peripheral Coordinator - Get Bonded Devices request.
   */
  mType: "iqrfEmbedCoordinator_BondedDevices";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBondedDevicesResponse100 {
  /**
   * Embedded peripheral Coordinator - Get Bonded Devices response.
   */
  mType: "iqrfEmbedCoordinator_BondedDevices";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Bit array indicating discovered nodes (addresses). Address 0 at bit0 of PData0, Address 1 at bit1 of PData0 etc.
       */
      bondedDevices: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBondNodeRequest100 {
  /**
   * Embedded peripheral Coordinator - Bond Node request.
   */
  mType: "iqrfEmbedCoordinator_BondNode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * A requested address for the bonded node. The address must not be used (bonded) yet. If this parameter equals to 0, then the 1st free address is assigned to the node.
       */
      reqAddr: number;
      /**
       * See IQRF OS User's and Reference guides (remote bonding, function bondNewNode).
       */
      bondingMask: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorBondNodeResponse100 {
  /**
   * Embedded peripheral Coordinator - Bond Node response.
   */
  mType: "iqrfEmbedCoordinator_BondNode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Address of the node newly bonded to the network.
       */
      bondAddr: number;
      /**
       * Number of bonded network nodes.
       */
      devNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorClearAllBondsRequest100 {
  /**
   * Embedded peripheral Coordinator - Clear All Bonds request.
   */
  mType: "iqrfEmbedCoordinator_ClearAllBonds";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorClearAllBondsResponse100 {
  /**
   * Embedded peripheral Coordinator - Clear All Bonds response.
   */
  mType: "iqrfEmbedCoordinator_ClearAllBonds";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorClearRemotelyBondedMidRequest100 {
  /**
   * Embedded peripheral Coordinator - Clear Remotely Bonded Module ID request.
   */
  mType: "iqrfEmbedCoordinator_ClearRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorClearRemotelyBondedMidResponse100 {
  /**
   * Embedded peripheral Coordinator - Clear Remotely Bonded Module ID response.
   */
  mType: "iqrfEmbedCoordinator_ClearRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveredDevicesRequest100 {
  /**
   * Embedded peripheral Coordinator - Get Discovered Nodes request.
   */
  mType: "iqrfEmbedCoordinator_DiscoveredDevices";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveredDevicesResponse100 {
  /**
   * Embedded peripheral Coordinator - Get Bonded Nodes response.
   */
  mType: "iqrfEmbedCoordinator_DiscoveredDevices";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Bit array indicating discovered nodes (addresses). Address 0 at bit0 of PData0, Address 1 at bit1 of PData0 etc.
       */
      bondedNodes?: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveryRequest100 {
  /**
   * Embedded peripheral Coordinator - Discovery request.
   */
  mType: "iqrfEmbedCoordinator_Discovery";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * TX Power used for discovery.
       */
      txPower: number;
      /**
       * Nonzero value specifies maxItems node address to be part of the discovery process.
       */
      maxAddr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveryResponse100 {
  /**
   * Embedded peripheral Coordinator - Discovery response.
   */
  mType: "iqrfEmbedCoordinator_Discovery";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of discovered nodes.
       */
      discNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveryDataRequest100 {
  /**
   * Embedded peripheral Coordinator - Discovery Data request.
   */
  mType: "iqrfEmbedCoordinator_DiscoveryData";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Address of the discovery data to read.
       */
      address: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorDiscoveryDataResponse100 {
  /**
   * Embedded peripheral Coordinator - Discovery Data response.
   */
  mType: "iqrfEmbedCoordinator_DiscoveryData";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array of bytes with discovery data.
       */
      discData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorEnableRemoteBondingRequest100 {
  /**
   * Embedded peripheral Coordinator - Enable Remote Bonding request.
   */
  mType: "iqrfEmbedCoordinator_EnableRemoteBonding";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * See IQRF OS User's and Reference guides (remote bonding, function bondNewNode).
       */
      bondingMask: number;
      /**
       * Enables remote bonding mode. If enabled then previously bonded nodes are forgotten.
       */
      control: boolean;
      /**
       * Optional data that can be used at Reset Custom DPA Handler event.
       */
      userData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorEnableRemoteBondingResponse100 {
  /**
   * Embedded peripheral Coordinator - Enable Remote Bonding request.
   */
  mType: "iqrfEmbedCoordinator_EnableRemoteBonding";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorReadRemotelyBondedMidRequest100 {
  /**
   * Embedded peripheral Coordinator - Read Remotely Bonded Module ID request.
   */
  mType: "iqrfEmbedCoordinator_ReadRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgid?: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorReadRemotelyBondedMidResponse100 {
  /**
   * Embedded peripheral Coordinator - Read Remotely Bonded Module ID response.
   */
  mType: "iqrfEmbedCoordinator_ReadRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Js driver response structure for given a command.
       */
      prebondedNodes: {
        /**
         * Module ID of the remotely pre-bonded node. It can be used later for bonding authorization later.
         */
        mid: number;
        /**
         * Optional bonding user data specified at Reset Custom DPA Handler event.
         */
        userData: number[];
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRebondRequest100 {
  /**
   * Embedded peripheral Coordinator - Rebond request.
   */
  mType: "iqrfEmbedCoordinator_Rebond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Address of the node to be re-bonded.
       */
      bondedAddr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRebondResponse100 {
  /**
   * Embedded peripheral Coordinator - Rebond request.
   */
  mType: "iqrfEmbedCoordinator_Rebond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of bonded nodes.
       */
      devNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRemoveBondRequest100 {
  /**
   * Embedded peripheral Coordinator - Remove Bond request.
   */
  mType: "iqrfEmbedCoordinator_RemoveBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Address of the node to be removed.
       */
      bondedAddr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRemoveBondResponse100 {
  /**
   * Embedded peripheral Coordinator - Remove Bond response.
   */
  mType: "iqrfEmbedCoordinator_RemoveBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of bonded nodes.
       */
      devNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRestoreRequest100 {
  /**
   * Embedded peripheral Coordinator - Restore request.
   */
  mType: "iqrfEmbedCoordinator_Restore";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * One block of the coordinator network info data previously obtained by a backup command.
       */
      netData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorRestoreResponse100 {
  /**
   * Embedded peripheral Coordinator - Restore response.
   */
  mType: "iqrfEmbedCoordinator_Restore";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSetDpaParamsRequest100 {
  /**
   * Embedded peripheral Coordinator - Set Dpa Params request.
   */
  mType: "iqrfEmbedCoordinator_SetDpaParams";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Configuration of the type of DPA value.
       */
      dpaValueStr: "LastRssi" | "Voltage" | "System" | "User";
      /**
       * Diagnosing the network behavior based on LED activities. Red LED flashes when Node or Coordinator receives network message. Green LED flashes when Coordinator sends network message or when Node routes network message.
       */
      ledDiagnostic: boolean;
      /**
       * A long fixed 200 ms timeslot is used. It allows easier tracking of network behavior.
       */
      fixedTimeslot: boolean;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSetDpaParamsResponse100 {
  /**
   * Embedded peripheral Coordinator - Set Dpa Params response.
   */
  mType: "iqrfEmbedCoordinator_SetDpaParams";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Previous configuration of the type of DPA value.
       */
      prevDpaValueStr: "LastRssi" | "Voltage" | "System" | "User";
      /**
       *  Previous diagnosing the network behavior based on LED activities. Red LED flashes when Node or Coordinator receives network message. Green LED flashes when Coordinator sends network message or when Node routes network message.
       */
      prevLedDiagnostic: boolean;
      /**
       * Previous a long fixed 200 ms timeslot is used. It allows easier tracking of network behavior.
       */
      prevFixedTimeslot: boolean;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSetHopsRequest100 {
  /**
   * Embedded peripheral Coordinator - Set Hops request.
   */
  mType: "iqrfEmbedCoordinator_SetHops";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Allows the specifying fixed number of hops used to send the DPA request or to specify an optimization algorithm to compute a integer of hops.
       */
      reqHops: number;
      /**
       * Allows the specifying fixed number of hops used to send the DPA response or to specify an optimization algorithm to compute a integer of hops.
       */
      rspHops?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSetHopsResponse100 {
  /**
   * Embedded peripheral Coordinator - Set Hops response.
   */
  mType: "iqrfEmbedCoordinator_SetHops";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Allows the specifying fixed number of hops used to send the DPA request or to specify an optimization algorithm to compute a integer of hops.
       */
      prevReqHops: number;
      /**
       * Allows the specifying fixed number of hops used to send the DPA response or to specify an optimization algorithm to compute a integer of hops.
       */
      prevRspHops: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSmartConnectRequest100 {
  /**
   * Embedded peripheral Coordinator - Smart Connect request.
   */
  mType: "iqrfEmbedCoordinator_SmartConnect";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * A requested address for the bonded node. The address must not be used (bonded) yet. If this parameter equals to 0, then the 1st free address is assigned to the node.
       */
      reqAddr: number;
      /**
       * Maximum number of FRCs used to test whether the Node was successfully bonded. If value is 0, then no test is performed and the command always succeeds.
       */
      bondingTestRetries: number;
      /**
       * Individual Bonding Key of the Node to bond.
       */
      ibk: number[];
      /**
       * MID of the Node to bond.
       */
      mid: number[];
      /**
       * RF channel used for bonding.
       */
      bondingChannel: number;
      /**
       * Virtual device address. Must equal to 0xFF if not used.
       */
      virtualDeviceAddress: number;
      /**
       * Optional data passed to the bonded node.
       */
      userData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedCoordinatorSmartConnectResponse100 {
  /**
   * Embedded peripheral Coordinator - Smart Connect response.
   */
  mType: "iqrfEmbedCoordinator_SmartConnect";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Address of the node newly bonded to the network.
       */
      bondAddr: number;
      /**
       * Number of bonded network nodes.
       */
      devNr: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEeepromReadRequest100 {
  /**
   * Embedded peripheral Memory - Read request.
   */
  mType: "iqrfEmbedEeeprom_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Length of data to read.
       */
      len: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEeepromReadResponse100 {
  /**
   * Embedded peripheral Memory - Read response.
   */
  mType: "iqrfEmbedEeeprom_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returned data.
       */
      memData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEeepromWriteRequest100 {
  /**
   * Embedded peripheral Memory - Write request.
   */
  mType: "iqrfEmbedEeeprom_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Data to be written.
       */
      memData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEeepromWriteResponse100 {
  /**
   * Embedded peripheral Memory - Write response.
   */
  mType: "iqrfEmbedEeeprom_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEepromReadRequest100 {
  /**
   * Embedded peripheral Memory - Read request.
   */
  mType: "iqrfEmbedEeprom_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Length of data to read.
       */
      len: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEepromReadResponse100 {
  /**
   * Embedded peripheral Memory - Read response.
   */
  mType: "iqrfEmbedEeprom_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returned data.
       */
      memData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEepromWriteRequest100 {
  /**
   * Embedded peripheral Memory - Write request.
   */
  mType: "iqrfEmbedEeprom_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Data to be written.
       */
      memData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedEepromWriteResponse100 {
  /**
   * Embedded peripheral Memory - Write response.
   */
  mType: "iqrfEmbedEeprom_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExploreEnumerateRequest100 {
  /**
   * Embedded peripheral Explore - Enumeration request.
   */
  mType: "iqrfEmbedExplore_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExploreEnumerateResponse100 {
  /**
   * Embedded peripheral Explore - Enumeration response.
   */
  mType: "iqrfEmbedExplore_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * DPA version.
       */
      dpaVer: number;
      /**
       * Number of all non-embedded peripherals implemented by Custom DPA Handler.
       */
      perNr: number;
      /**
       * Bits array (starting from LSb of the 1st byte) specifying which of 32 embedded peripherals are enabled in the HWP Configuration.
       */
      embPers: number[];
      /**
       * Hardware profile version.
       */
      hwpIdVer: number;
      /**
       * Various flags.
       */
      flags: number;
      /**
       * Bits array (starting from LSb of the 1st byte) specifying which of non-embedded peripherals are implemented.
       */
      userPers: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExploreMorePeripheralsInformationRequest100 {
  /**
   * Embedded peripheral Explore - More Peripheral Information request.
   */
  mType: "iqrfEmbedExplore_MorePeripheralsInformation";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Peripheral to get information about.
       */
      per: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExploreMorePeripheralsInformationResponse100 {
  /**
   * Embedded peripheral Explore - More Peripheral Information response.
   */
  mType: "iqrfEmbedExplore_MorePerInfo";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returns the same information as Get peripheral information but for up to 14 peripherals of consecutive indexes starting with the specified PCMD.
       */
      result: {
        /**
         * Extended peripheral characteristic. See Extended Peripheral Characteristic constants.
         */
        perTe: number;
        /**
         * Peripheral type. If the peripheral is not supported or enabled, then PerTx = PERIPHERAL_TYPE_DUMMY. See Peripheral Types constants.
         */
        perT: number;
        /**
         * Optional peripheral specific information.
         */
        par1?: number;
        /**
         * Optional peripheral specific information.
         */
        par2?: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExplorePeripheralInformationRequest100 {
  /**
   * Embedded peripheral Explore - Peripheral Information request.
   */
  mType: "iqrfEmbedExplore_PeripheralInformation";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Peripheral to get information about.
       */
      per: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedExplorePeripheralInformationResponse100 {
  /**
   * Embedded peripheral Explore - Peripheral Information response.
   */
  mType: "iqrfEmbedExplore_PeripheralInformation";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Extended peripheral characteristic. See Extended Peripheral Characteristic constants.
       */
      perTe: number;
      /**
       * Peripheral type. If the peripheral is not supported or enabled, then PerTx = PERIPHERAL_TYPE_DUMMY. See Peripheral Types constants.
       */
      perT: number;
      /**
       * Optional peripheral specific information.
       */
      par1: number;
      /**
       * Optional peripheral specific information.
       */
      par2: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcExtraResultRequest100 {
  /**
   * Embedded peripheral FRC - Extra Result request.
   */
  mType: "iqrfEmbedFrc_ExtraResult";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgid?: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcExtraResultResponse100 {
  /**
   * Embedded peripheral FRC - Extra Result response.
   */
  mType: "iqrfEmbedFrc_ExtraResult";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * FRC data.
       */
      frcData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSendRequest100 {
  /**
   * Embedded peripheral FRC - Send request.
   */
  mType: "iqrfEmbedFrc_Send";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Specifies data to be collected.
       */
      frcCmd: number;
      /**
       * User data.
       */
      userData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSendResponse100 {
  /**
   * Embedded peripheral FRC - Send response.
   */
  mType: "iqrfEmbedFrc_Send";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * FRC status.
       */
      status: number;
      /**
       * FRC data.
       */
      frcData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSendSelectiveRequest100 {
  /**
   * Embedded peripheral FRC - Send Selective request.
   */
  mType: "iqrfEmbedFrc_SendSelective";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Specifies data to be collected.
       */
      frcCmd: number;
      /**
       * Selected nodes 1 ... 30.
       */
      selNodes: number[];
      /**
       * User data.
       */
      userData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSendSelectiveResponse100 {
  /**
   * Embedded peripheral FRC - Send Selective response.
   */
  mType: "iqrfEmbedFrc_SendSelective";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * FRC status.
       */
      status: number;
      /**
       * FRC data.
       */
      frcData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSetParamsRequest100 {
  /**
   * Embedded peripheral FRC - Set Params request.
   */
  mType: "iqrfEmbedFrc_SetParams";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Maximum time reserved for preparing return FRC value.
       */
      params: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedFrcSetParamsResponse100 {
  /**
   * Embedded peripheral FRC - Set Params response.
   */
  mType: "iqrfEmbedFrc_SetParams";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Previous FRC response time.
       */
      prevParams: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoDirectionRequest100 {
  /**
   * Embedded peripheral IO - Direction request.
   */
  mType: "iqrfEmbedIo_Direction";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of ports.
       */
      ports: {
        /**
         *  Specifies port to setup a direction.
         */
        port: number;
        /**
         * Masks pins of the port.
         */
        mask: number;
        /**
         * Actual direction.
         */
        value: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoDirectionResponse100 {
  /**
   * Embedded peripheral IO - Direction response.
   */
  mType: "iqrfEmbedIo_Direction";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoGetRequest100 {
  /**
   * Embedded peripheral IO - Get request.
   */
  mType: "iqrfEmbedIo_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoGetResponse100 {
  /**
   * Embedded peripheral IO - Get response.
   */
  mType: "iqrfEmbedIo_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array of ports.
       */
      ports: {
        /**
         *  Specifies port to setup a direction.
         */
        port: number;
        /**
         * Masks pins of the port.
         */
        mask: number;
        /**
         * Actual direction.
         */
        value: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoSetRequest100 {
  /**
   * Embedded peripheral IO - Set request.
   */
  mType: "iqrfEmbedIo_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of ports.
       */
      ports: {
        /**
         *  Specifies port to setup a direction.
         */
        port: number;
        /**
         * Masks pins of the port.
         */
        mask: number;
        /**
         * Actual direction.
         */
        value: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedIoSetResponse100 {
  /**
   * Embedded peripheral IO - Set response.
   */
  mType: "iqrfEmbedIo_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgid?: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgGetRequest100 {
  /**
   * Embedded peripheral Ledg - Get request.
   */
  mType: "iqrfEmbedLedg_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgGetResponse100 {
  /**
   * Embedded peripheral Ledg - Get request.
   */
  mType: "iqrfEmbedLedg_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * LED status.
       */
      onOff: boolean;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgPulseRequest100 {
  /**
   * Embedded peripheral Ledg - Pulse request.
   */
  mType: "iqrfEmbedLedg_Pulse";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgPulseResponse100 {
  /**
   * Embedded peripheral Ledg - Pulse response.
   */
  mType: "iqrfEmbedLedg_Pulse";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgSetRequest100 {
  /**
   * Embedded peripheral Ledg - Set request.
   */
  mType: "iqrfEmbedLedg_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Turns on/off LED.
       */
      onOff: boolean;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedgSetResponse100 {
  /**
   * Embedded peripheral Ledg - Set response.
   */
  mType: "iqrfEmbedLedg_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrGetRequest100 {
  /**
   * Embedded peripheral Ledr - Get request.
   */
  mType: "iqrfEmbedLedr_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrGetResponse100 {
  /**
   * Embedded peripheral Ledr - Get request.
   */
  mType: "iqrfEmbedLedr_Get";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * LED status.
       */
      onOff: boolean;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrPulseRequest100 {
  /**
   * Embedded peripheral Ledr - Pulse request.
   */
  mType: "iqrfEmbedLedr_Pulse";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrPulseResponse100 {
  /**
   * Embedded peripheral Ledr - Pulse response.
   */
  mType: "iqrfEmbedLedr_Pulse";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrSetRequest100 {
  /**
   * Embedded peripheral Ledr - Set request.
   */
  mType: "iqrfEmbedLedr_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Turns on/off LED.
       */
      onOff: boolean;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedLedrSetResponse100 {
  /**
   * Embedded peripheral Ledr - Set response.
   */
  mType: "iqrfEmbedLedr_Set";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeBackupRequest100 {
  /**
   * Embedded peripheral Node - Backup request.
   */
  mType: "iqrfEmbedNode_Backup";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * This command reads coordinator network information data that can be then restored to another coordinator in order to make a clone of the original coordinator.
       */
      index: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeBackupResponse100 {
  /**
   * Embedded peripheral Node - Backup response.
   */
  mType: "iqrfEmbedNode_Backup";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array of bytes with the backup content.
       */
      rData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeClearRemotelyBondedMidRequest100 {
  /**
   * Embedded peripheral Node - Clear Remotely Bonded Module ID request.
   */
  mType: "iqrfEmbedNode_ClearRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeClearRemotelyBondedMidResponse100 {
  /**
   * Embedded peripheral Node - Clear Remotely Bonded Module ID response.
   */
  mType: "iqrfEmbedNode_ClearRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeEnableRemoteBondRequest100 {
  /**
   * Embedded peripheral Node - Enable Remote Bond request.
   */
  mType: "iqrfEmbedNode_EnableRemoteBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * See IQRF OS User's and Reference guides (remote bonding, function bondNewNode).
       */
      bondingMask: number;
      /**
       * Enables remote bonding mode. If enabled then previously bonded nodes are forgotten.
       */
      control: boolean;
      /**
       * Optional data that can be used at Reset Custom DPA Handler event.
       */
      userData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeEnableRemoteBondResponse100 {
  /**
   * Embedded peripheral Node - Enable Remote Bond response.
   */
  mType: "iqrfEmbedNode_EnableRemoteBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeReadRequest100 {
  /**
   * Embedded peripheral Node - Read request.
   */
  mType: "iqrfEmbedNode_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeReadResponse100 {
  /**
   * Embedded peripheral Node - Read response.
   */
  mType: "iqrfEmbedNode_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      rData?: {
        /**
         * Network address.
         */
        ntwAddr: number;
        /**
         * Virtual routing number.
         */
        ntwVrn: number;
        /**
         * Zone index.
         */
        ntwZin: number;
        /**
         * Discovery id.
         */
        ntwDid: number;
        /**
         * Parent virtual routing number.
         */
        ntwPvrn: number;
        /**
         * User address 2B.
         */
        ntwUserAddr: number;
        /**
         * Network identification (NID0/NID1).
         */
        ntwId: number;
        /**
         * VRN of first Node in given zone.
         */
        ntwVrnFnz: number;
        /**
         * Network configuration.
         */
        ntwCfg: number;
        /**
         * Indicates whether the Node device is bonded.
         */
        bonded: boolean;
        [k: string]: any;
      };
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeReadRemotelyBondedMidRequest100 {
  /**
   * Embedded peripheral Node - Read Remotely Bonded Mid request.
   */
  mType: "iqrfEmbedNode_ReadRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeReadRemotelyBondedMidResponse100 {
  /**
   * Embedded peripheral Coordinator - Read Remotely Bonded Module ID response.
   */
  mType: "iqrfEmbedNode_ReadRemotelyBondedMid";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Js driver response structure for given a command.
       */
      prebondedNodes: {
        /**
         * Module ID of the remotely pre-bonded node. It can be used later for bonding authorization later.
         */
        mid: number;
        /**
         * Optional bonding user data specified at Reset Custom DPA Handler event.
         */
        userData: number[];
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeRemoveBondRequest100 {
  /**
   * Embedded peripheral Node - Remove Bond Address request.
   */
  mType: "iqrfEmbedNode_RemoveBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeRemoveBondResponse100 {
  /**
   * Embedded peripheral Node - Remove Bond Address response.
   */
  mType: "iqrfEmbedNode_RemoveBond";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeRestoreRequest100 {
  /**
   * Embedded peripheral Node - Restore request.
   */
  mType: "iqrfEmbedNode_Restore";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of restored data.
       */
      netData: {
        index?: number;
        [k: string]: any;
      };
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedNodeRestoreResponse100 {
  /**
   * Embedded peripheral Node - Restore response.
   */
  mType: "iqrfEmbedNode_Restore";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsBatchRequest100 {
  /**
   * Embedded peripheral OS - Batch request.
   */
  mType: "iqrfEmbedOs_Batch";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      innerReqs: {
        /**
         * Length of the inner request
         */
        length: number;
        /**
         * Binary buffer with DPA request
         */
        rawStr: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsBatchResponse100 {
  /**
   * Embedded peripheral OS - Batch response.
   */
  mType: "iqrfEmbedOs_Batch";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsInitResetRequest100 {
  /**
   * Embedded peripheral OS - Reset request.
   */
  mType: "iqrfEmbedOs_Reset";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: string;
      /**
       * Hardware profile identification.
       */
      hwpId?: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsInitResetResponse100 {
  /**
   * Embedded peripheral OS - Reset response.
   */
  mType: "iqrfEmbedOs_Reset";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsInitRestartRequest100 {
  /**
   * Embedded peripheral OS - Restart request.
   */
  mType: "iqrfEmbedOs_Restart";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: string;
      /**
       * Hardware profile identification.
       */
      hwpId?: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsInitRestartResponse100 {
  /**
   * Embedded peripheral OS - Restart response.
   */
  mType: "iqrfEmbedOs_Restart";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsLoadCodeRequest100 {
  /**
   * Embedded peripheral OS - Load Code request.
   */
  mType: "iqrfEmbedOs_LoadCode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Action flags.
       */
      flags: number;
      /**
       * A physical address at external EEPROM memory to load the code image from.
       */
      address: number;
      /**
       * Length of the code image in bytes at the external EEPROM.
       */
      length: number;
      /**
       * Ones complement Fletcher-16 checksum of the code image.
       */
      checkSum: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsLoadCodeResponse100 {
  /**
   * Embedded peripheral OS - Load Code response.
   */
  mType: "iqrfEmbedOs_LoadCode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * The checksum matches a checksum of a code at the external EEPROM.
       */
      result: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsReadRequest100 {
  /**
   * Embedded peripheral OS - Read request.
   */
  mType: "iqrfEmbedOs_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsReadResponse100 {
  /**
   * Embedded peripheral OS - Read response.
   */
  mType: "iqrfEmbedOs_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * TR Module ID.
       */
      mid: number;
      /**
       * IQRF OS version.
       */
      osVersion: number;
      /**
       * TR MCU type.
       */
      trMcuType: number;
      /**
       * IQRF OS build.
       */
      osBuild: number;
      /**
       * See lastRSSI at IQRF OS Reference Guide.
       */
      rssi: number;
      /**
       * Module supply voltage, contains real voltage value.
       */
      supplyVoltage: number;
      /**
       * See DPA guide.
       */
      flags: number;
      /**
       * See DPA guide.
       */
      slotLimits: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsReadResponse110 {
  /**
   * Embedded peripheral OS - Read response.
   */
  mType: "iqrfEmbedOs_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * TR Module ID.
       */
      mid: number;
      /**
       * IQRF OS version.
       */
      osVersion: number;
      /**
       * TR MCU type.
       */
      trMcuType: number;
      /**
       * IQRF OS build.
       */
      osBuild: number;
      /**
       * See lastRSSI at IQRF OS Reference Guide.
       */
      rssi: number;
      /**
       * Module supply voltage, contains real voltage value.
       */
      supplyVoltage: number;
      /**
       * See DPA guide.
       */
      flags: number;
      /**
       * See DPA guide.
       */
      slotLimits: number;
      /**
       * Individual Bonding Key.
       */
      ibk: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsReadCfgRequest100 {
  /**
   * Embedded peripheral OS - Read Configuration request.
   */
  mType: "iqrfEmbedOs_ReadCfg";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsReadCfgResponse100 {
  /**
   * Embedded peripheral OS - Read Configuration response.
   */
  mType: "iqrfEmbedOs_ReadCfg";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Checksum of the Configuration part.
       */
      checkSum: number;
      /**
       * Content the configuration memory block from address 0x01 to 0x1F.
       */
      cfgBytes: number[];
      /**
       * See parameter of setupRFPGM IQRF OS function.
       */
      rfPgm: number;
      undocumented: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsRunRfpgmRequest100 {
  /**
   * Embedded peripheral OS - Run Rfpgm request.
   */
  mType: "iqrfEmbedOs_RunRfpgm";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsRunRfpgmResponse100 {
  /**
   * Embedded peripheral OS - Run Rfpgm response.
   */
  mType: "iqrfEmbedOs_RunRfpgm";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSelectiveBatchRequest100 {
  /**
   * Embedded peripheral OS - Selective Batch request.
   */
  mType: "iqrfEmbedOs_SelectiveBatch";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array if integer values corresponding to the selected nodes.
       */
      selNodes: number[];
      innerReqs: {
        /**
         * Length of the inner request
         */
        length: number;
        /**
         * Binary buffer with DPA request
         */
        rawStr: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSelectiveBatchResponse100 {
  /**
   * Embedded peripheral OS - Selective Batch response.
   */
  mType: "iqrfEmbedOs_SelectiveBatch";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSetSecurityRequest100 {
  /**
   * Embedded peripheral OS - Set Security request.
   */
  mType: "iqrfEmbedOs_SetSecurity";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Sets access password or user key stored at data.
       */
      type: number;
      /**
       * Hardware profile identification.
       */
      data: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSetSecurityResponse100 {
  /**
   * Embedded peripheral OS - Set Security response.
   */
  mType: "iqrfEmbedOs_SetSecurity";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSleepRequest100 {
  /**
   * Embedded peripheral OS - Sleep request.
   */
  mType: "iqrfEmbedOs_Sleep";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Sleep time in 2.097 s or 32.768 ms units. See Control.bit.4.
       */
      time: number;
      /**
       * See DPA guide.
       */
      control: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsSleepResponse100 {
  /**
   * Embedded peripheral OS - Sleep response.
   */
  mType: "iqrfEmbedOs_Sleep";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsWriteCfgRequest100 {
  /**
   * Embedded peripheral OS - Write Configuration request.
   */
  mType: "iqrfEmbedOs_WriteCfg";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Checksum of the Configuration part.
       */
      checkSum: number;
      /**
       * Content the configuration memory block from address 0x01 to 0x1F.
       */
      cfgBytes: number[];
      /**
       * See parameter of setupRFPGM IQRF OS function.
       */
      rfPgm: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsWriteCfgResponse100 {
  /**
   * Embedded peripheral OS - Write Configuration response.
   */
  mType: "iqrfEmbedOs_WriteCfg";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsWriteCfgByteRequest100 {
  /**
   * Embedded peripheral OS - Write Configuration Byte request.
   */
  mType: "iqrfEmbedOs_WriteCfgByte";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      bytes: {
        /**
         * Address of the item at configuration memory block.
         */
        address: number;
        /**
         * Value of the configuration item to write.
         */
        value: number;
        /**
         * Specifies bits of the configuration byte to be modified by the corresponding bits of the Value parameter.
         */
        mask: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedOsWriteCfgByteResponse100 {
  /**
   * Embedded peripheral OS - Write Configuration Byte response.
   */
  mType: "iqrfEmbedOs_WriteCfgByte";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedRamReadRequest100 {
  /**
   * Embedded peripheral Memory - Read request.
   */
  mType: "iqrfEmbedRam_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Length of data to read.
       */
      len: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedRamReadResponse100 {
  /**
   * Embedded peripheral Memory - Read response.
   */
  mType: "iqrfEmbedRam_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returned data.
       */
      memData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedRamWriteRequest100 {
  /**
   * Embedded peripheral Memory - Write request.
   */
  mType: "iqrfEmbedRam_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Memory address to read from.
       */
      address: number;
      /**
       * Data to be written.
       */
      memData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedRamWriteResponse100 {
  /**
   * Embedded peripheral Memory - Write response.
   */
  mType: "iqrfEmbedRam_Write";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedSpiWriteReadRequest100 {
  /**
   * Embedded peripheral SPI - Write Read request.
   */
  mType: "iqrfEmbedSpi_WriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Specifies timeout in 10 ms unit to wait for data to be read after data is (optionally) written.
       */
      readTimeout: number;
      /**
       * Optional data to be written.
       */
      writtenData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedSpiWriteReadResponse100 {
  /**
   * Embedded peripheral SPI - Write Read response.
   */
  mType: "iqrfEmbedSpi_WriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Optional data to be written.
       */
      readData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedThermometerReadRequest100 {
  /**
   * Embedded peripheral Thermometer - Read request.
   */
  mType: "iqrfEmbedThermometer_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedThermometerReadResponse100 {
  /**
   * Embedded peripheral Thermometer - Read response.
   */
  mType: "iqrfEmbedThermometer_Read";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Temperature value in *C.
       */
      temperature: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mcat) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartClearWriteReadRequest100 {
  /**
   * Embedded peripheral UART - Clear Write Read request.
   */
  mType: "iqrfEmbedUart_ClearWriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Specifies timeout in 10 ms unit to wait for data to be read after data is (optionally) written.
       */
      readTimeout: number;
      /**
       * Optional data to be written.
       */
      writtenData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartClearWriteReadResponse100 {
  /**
   * Embedded peripheral UART - Clear Write Read response.
   */
  mType: "iqrfEmbedUart_ClearWriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Optional data to be written.
       */
      readData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartCloseRequest100 {
  /**
   * Embedded peripheral UART - Close request.
   */
  mType: "iqrfEmbedUart_Close";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartCloseResponse100 {
  /**
   * Embedded peripheral UART - Close request.
   */
  mType: "iqrfEmbedUart_Close";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartOpenRequest100 {
  /**
   * Embedded peripheral UART - Open request.
   */
  mType: "iqrfEmbedUart_Open";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * UART is opened with this baudrate.
       */
      baudrateStr: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartOpenResponse100 {
  /**
   * Embedded peripheral UART - Write Read response.
   */
  mType: "iqrfEmbedUart_Open";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartWriteReadRequest100 {
  /**
   * Embedded peripheral UART - Write Read request.
   */
  mType: "iqrfEmbedUart_WriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Specifies timeout in 10 ms unit to wait for data to be read after data is (optionally) written.
       */
      readTimeout: number;
      /**
       * Optional data to be written.
       */
      writtenData: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfEmbedUartWriteReadResponse100 {
  /**
   * Embedded peripheral UART - Write Read response.
   */
  mType: "iqrfEmbedUart_WriteRead";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Optional data to be written.
       */
      readData: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightDecrementPowerRequest100 {
  /**
   * Standard peripheral Light - Decrement Power request.
   */
  mType: "iqrfLight_DecrementPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of objects with the following fields.
       */
      lights: {
        /**
         * Zero based index of the light to set.
         */
        index: number;
        /**
         * Decreses power level.
         */
        power: number;
        /**
         * Time in seconds. Allowed values are <1;127> or 60*<1;127>.
         */
        time?: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightDecrementPowerResponse100 {
  /**
   * Standard peripheral Light - Decrement Power response.
   */
  mType: "iqrfLight_DecrementPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array integers corresponding to the previous power level of each selected light. If the unimplemented light was selected the returned value is 0.
       */
      prevVals: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightEnumerateRequest100 {
  /**
   * Standard peripheral Light - Enumeration request.
   */
  mType: "iqrfLight_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightEnumerateResponse100 {
  /**
   * Standard peripheral Light - Enumeration response.
   */
  mType: "iqrfLight_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Number of implemented binary lights.
       */
      lights: number;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightIncrementPowerRequest100 {
  /**
   * Standard peripheral Light - Increment Power request.
   */
  mType: "iqrfLight_IncrementPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of objects with the following fields.
       */
      lights: {
        /**
         * Zero based index of the light to set.
         */
        index: number;
        /**
         * Increases power level.
         */
        power: number;
        /**
         * Time in seconds. Allowed values are <1;127> or 60*<1;127>.
         */
        time?: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightIncrementPowerResponse100 {
  /**
   * Standard peripheral Light - Increment Power response.
   */
  mType: "iqrfLight_IncrementPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array integers corresponding to the previous power level of each selected light. If the unimplemented light was selected the returned value is 0.
       */
      prevVals: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightSetPowerRequest100 {
  /**
   * Standard peripheral Light - Set Power request.
   */
  mType: "iqrfLight_SetPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Array of objects with the following fields.
       */
      lights: {
        /**
         * Zero based index of the light to set.
         */
        index: number;
        /**
         * Power level of the light from range <0;100>. Value 127 keeps current power level allowing to only report power level.
         */
        power: number;
        /**
         * Time in seconds. Allowed values are <1;127> or 60*<1;127>.
         */
        time?: number;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfLightSetPowerResponse100 {
  /**
   * Standard peripheral Light - Set Power response.
   */
  mType: "iqrfLight_SetPower";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Array integers corresponding to the previous power level of each selected light. If the unimplemented light was selected the returned value is 0.
       */
      prevVals: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfRawRequest100 {
  /**
   * Message type for Raw communication.
   */
  mType: "iqrfRaw";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response
     */
    timeout?: number;
    req: {
      /**
       * Binary buffer with DPA request
       */
      request: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfRawResponse100 {
  /**
   * Message type for Raw communication.
   */
  mType: "iqrfRaw";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response
     */
    timeout?: number;
    rsp: {
      /**
       * Binary buffer with DPA response
       */
      response: string;
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfRawHdpRequest100 {
  /**
   * Message type for Raw Hdp communication.
   */
  mType: "iqrfRawHdp";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Peripheral integer.
       */
      pNum: number;
      /**
       * Peripheral command.
       */
      pCmd: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Binary buffer with DPA request data.
       */
      rData?: number[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfRawHdpResponse100 {
  /**
   * Message type for Raw Hdp communication.
   */
  mType: "iqrfRawHdp";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Peripheral number.
       */
      pNum: number;
      /**
       * Peripheral command.
       */
      pCmd: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Binary buffer with DPA response data.
       */
      rData?: number[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfSensorEnumerateRequest100 {
  /**
   * Standard peripheral Sensor - Enumeration request.
   */
  mType: "iqrfSensor_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfSensorEnumerateResponse100 {
  /**
   * Message type for IQRF standard communication.
   */
  mType: "iqrfSensor_Enumerate";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returns array of objects for every sensor, see its description.
       */
      result: {
        /**
         * Value type of the sensor (quantity).
         */
        type: number;
        /**
         * Name of the sensor (quantity).
         */
        name: string;
        /**
         *  Short name of the sensor (quantity). Typically it is a symbol used at physics.
         */
        shortName: string;
        /**
         * Unit of the quantity. Dimensionless quantities has "".
         */
        unit: string;
        /**
         * Array of FRC commands supported by the sensor.
         */
        frcs: number[];
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfSensorFrcRequest100 {
  /**
   * Standard peripheral Sensor - FRC request.
   */
  mType: "iqrfSensor_Frc";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr?: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      /**
       * Type of sensor (quantity) to read values of. Use iqrf.sensor.STD_SENSOR_TYPE_* constant. Use 0 to specify the sensor only by sensorIndex parameter.
       */
      sensorType: number;
      /**
       * Index of the sensor. If the sensor type is specified, then its is an index among of all sensors of the specified type. If sensorType is 0 then it is overall sensor index. Some FRC commands might use top 3 bits of this parameter for passing additional data.
       */
      sensorIndex: number;
      /**
       * One of predefined standard sensor FRC commands. See iqrf.sensor.STD_SENSOR_FRC_* constants.
       */
      frcCmd: number;
      /**
       * Array if integer values corresponding to the selected nodes. Use default value to select all nodes and use sleepAfterFrc parameter.
       */
      selectedNodes?: number[];
      /**
       * Object with the following fields to put the nodes into sleep mode after the FRC is finished.
       */
      sleepAfterFrc?: {
        /**
         * See DPA documentation https://www.iqrf.org/DpaTechGuide for details.
         */
        time?: number;
        /**
         * See DPA documentation https://www.iqrf.org/DpaTechGuide for details.
         */
        control?: number;
        [k: string]: any;
      };
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfSensorFrcResponse100 {
  /**
   * Standard peripheral Sensor - FRC response.
   */
  mType: "iqrfSensor_Frc";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returns array of objects for every sensor, see its description.
       */
      result: {
        /**
         * Value type of the sensor (quantity).
         */
        type: number;
        /**
         * Name of the sensor (quantity).
         */
        name: string;
        /**
         *  Short name of the sensor (quantity). Typically it is a symbol used at physics.
         */
        shortName: string;
        /**
         * Value of the sensor.
         */
        value: number;
        /**
         * Unit of the quantity. Dimensionless quantities has "".
         */
        unit: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ParamsReadwt = ParamsReadwtUndefined | ParamsReadwtSenIndex | ParamsReadwtArrIndexes;

export interface IqrfSensorReadSensorsWithTypesRequest100 {
  /**
   * Standard peripheral Sensor - Read with Types request.
   */
  mType: "iqrfSensor_ReadSensorsWithTypes";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    req: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId?: number;
      params: ParamsReadwt;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * No parameters: reads 1st sensor.
 */
export interface ParamsReadwtUndefined {
  [k: string]: any;
}
/**
 * Sensor index to read.
 */
export interface ParamsReadwtSenIndex {
  /**
   * Specifies sensor to read data from, -1 reads all sensors.
   */
  sensorIndexes?: number;
  [k: string]: any;
}
/**
 * Array of indexes to read.
 */
export interface ParamsReadwtArrIndexes {
  /**
   * Specifies sensors to read as array of indexes.
   */
  sensor_indexes?: number[];
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface IqrfSensorReadSensorsWithTypesResponse100 {
  /**
   * Standard peripheral Sensor - Read with Types response.
   */
  mType: "iqrfSensor_ReadSensorsWithTypes";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    /**
     * Timeout to wait for IQRF DPA response.
     */
    timeout?: number;
    rsp: {
      /**
       * Network device address.
       */
      nAdr: number;
      /**
       * Hardware profile identification.
       */
      hwpId: number;
      /**
       * DPA error code.
       */
      rCode: number;
      /**
       * DPA value.
       */
      dpaVal: number;
      /**
       * Returns array of objects for every sensor, see its description.
       */
      result: {
        /**
         * Value type of the sensor (quantity).
         */
        type: number;
        /**
         * Name of the sensor (quantity).
         */
        name: string;
        /**
         *  Short name of the sensor (quantity). Typically it is a symbol used at physics.
         */
        shortName: string;
        /**
         * Value of the sensor.
         */
        value: number;
        /**
         * Unit of the quantity. Dimensionless quantities has "".
         */
        unit: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    raw?: {
      /**
       * Binary buffer with DPA request.
       */
      request: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      requestTs: string;
      /**
       * Binary buffer with DPA confirmation.
       */
      confirmation: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      confirmationTs: string;
      /**
       * Binary buffer with DPA response.
       */
      response: string;
      /**
       * YYYY-MM-DDTHH:MM:SS.MS
       */
      responseTs: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngDaemonModeRequest100 {
  /**
   * Daemon runtime configuration - Change the daemon mode request.
   */
  mType: "mngDaemon_Mode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Operation mode.
       */
      operMode: "operational" | "service" | "forwarding";
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngDaemonModeResponse100 {
  /**
   * Daemon runtime configuration - Change the daemon mode response.
   */
  mType: "mngDaemon_Mode";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Operation mode.
       */
      operMode: "operational" | "service" | "forwarding";
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngDaemonRestartRequest100 {
  /**
   * Daemon runtime management - restart the daemon request.
   */
  mType: "mngDaemon_Restart";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Time to restart the daemon.
       */
      timeToRestart: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngDaemonRestartResponse100 {
  /**
   * Daemon runtime management - restart the daemon response.
   */
  mType: "mngDaemon_Restart";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Time to restart.
       */
      timeToRestart: number;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedAddTaskRequest100 {
  /**
   * Scheduler management - Add Task request.
   */
  mType: "mngSched_AddTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Scheduled task.
       */
      task: string;
      /**
       * 7 items of cron syntax...
       */
      cronTime: string[];
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedAddTaskResponse100 {
  /**
   * Scheduler management - Add Task response.
   */
  mType: "mngSched_AddTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mcat) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedGetTaskRequest100 {
  /**
   * Scheduler management - Get Task request.
   */
  mType: "mngSched_GetTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedGetTaskResponse100 {
  /**
   * Scheduler management - Add Task response.
   */
  mType: "mngSched_GetTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      /**
       * Task.
       */
      task: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedListRequest100 {
  /**
   * Scheduler management - List request.
   */
  mType: "mngSched_List";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedListResponse100 {
  /**
   * Scheduler management - List response.
   */
  mType: "mngSched_List";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Command identifier.
       */
      clientId: string;
      tasks: {
        /**
         * Task identifier.
         */
        taskId: number;
        /**
         * Task.
         */
        task: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status?: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedPerTaskRequest100 {
  /**
   * Scheduler management - Per Task request.
   */
  mType: "mngSched_PerTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Period in seconds in timestamp format '2018-01-03T16:00:09.859515'
       */
      timePeriod: number;
      /**
       * Delayed start in seconds in timestamp format '2018-01-03T16:00:09.859515'
       */
      timePoint?: number;
      /**
       * Task.
       */
      task: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedPerTaskResponse100 {
  /**
   * Scheduler management - Per Task response.
   */
  mType: "mngSched_PerTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedRemoveAllRequest100 {
  /**
   * Scheduler management - Remove All request.
   */
  mType: "mngSched_RemoveAll";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedRemoveAllResponse100 {
  /**
   * Scheduler management - Remove All response.
   */
  mType: "mngSched_RemoveAll";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedRemoveTaskRequest100 {
  /**
   * Scheduler management - Remove Task request.
   */
  mType: "mngSched_RemoveTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedRemoveTaskResponse100 {
  /**
   * Scheduler management - Remove Task response.
   */
  mType: "mngSched_RemoveTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * IQRF GW daemon API (general or mType) status.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedStartTaskRequest100 {
  /**
   * Scheduler management - Get Task request.
   */
  mType: "mngSched_StartTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedStartTaskResponse100 {
  /**
   * Scheduler management - Add Task response.
   */
  mType: "mngSched_StartTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      /**
       * Task.
       */
      task: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedStopTaskRequest100 {
  /**
   * Scheduler management - Get Task request.
   */
  mType: "mngSched_StopTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    req: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      [k: string]: any;
    };
    /**
     * Flag that includes additional parameters in the response.
     */
    returnVerbose?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface MngSchedStopTaskResponse100 {
  /**
   * Scheduler management - Add Task response.
   */
  mType: "mngSched_StopTask";
  data: {
    /**
     * Message identification for binding request with response.
     */
    msgId: string;
    rsp: {
      /**
       * Client identifier.
       */
      clientId: string;
      /**
       * Task identifier.
       */
      taskId: number;
      /**
       * Task.
       */
      task: string;
      [k: string]: any;
    };
    /**
     * IQRF GW daemon instance identification.
     */
    insId?: string;
    /**
     * Status of operation.
     */
    status: number;
    /**
     * IQRF GW daemon API (general or mType) status in string form.
     */
    statusStr?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
